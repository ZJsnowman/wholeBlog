---
title: Android兼容性问题的两种处理方法
date: 2016-11-12 18:38:49
tags: [Android]
---


当我们处理兼容性问题的时候有两种策略可以选择,一种是**回退**,一种是**复制**.<!-- more -->


回退是指,应用在新系统上用系统的特色功能及代码,而在旧系统上运行时,则回退使用早期的特色功能.
从技术的手段角度来说,这是通过在运行时检查SDK版本来实现的.

复制也叫模仿.意思是旧平台可提供类似于新平台的特色功能,而不再回退使用旧平台的功能.具体细分
为两种:
1. 按需复制.仅在老平台上使用复制功能.
2. 替换复制.无论新老平台都使用复制功能,即便是在有原生支持的新平台上.
 
  借助支持库使用fragment就是替换复制策略的运用.即使应用运行的设备支持使用
android.app.Fragment原生类,应用也总是使用android.support.v4.Fragment替换类.

回退与复制,哪一种策略更好呢?显然复制策略更胜一筹.它的主要优势在于,无论在哪个系统版本上,复
制功能都能保持统一的风格.这一点尤其是用于替换复制策略,使用该策略可以保证任何系统上都运行着
同样的代码.另外,应用的设计和测试人员也都会因此受益,因为他们只需要设计一种用户界面风格以及
测试验证一套应用交互.最后,使用复制策略,用户无需升级设备,就可以使应用看上去像全新的应用.

总结完了复制策略的优势,再来看看它的两个主要缺点.
- 为了保持最新,必须依赖于第三方库.
- 与设备上的其他应用相比,使用复制策略的应用看上去有点另类.因为与手机上标准应用风格不一致,
所以看上去会非常突兀.

## 栗子 ##
举个简单的栗子.比如获取颜色

``` java
 int color = getResources().getColor(R.color.mycolor);
```

这个是api**1**时代的方法,所以可以随便使用,不存在兼容性问题.
如果我使用下面的方法来获取颜色.

```java
 int color = getColor(R.color.myColor);  //23及以上支持这个方法 
``` 

这个是api**23**添加进来的方法,这个时候就存在兼容性问题.api22及以下都不存在这个方法.那么这个时候
就不能随意使用这个方法来获取颜色值了.
一般这个时候lint检查的时候就会提示你了.
怎么处理呢?
1. 使用老的api 
2. 在api22以下使用老的api,在api23及以上使用新的api.
3. 如果你确定这行代码只会在api23及以上的机器上调用,也可以直接用新的api,不推荐这样做,因为你不知道的
你的app会在什么环境下运行.	
关于第二种方法可以通过以下代码判断.

``` java
 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            mTestTv.setTextColor(getColor(R.color.colorAccent));
        }
else{
		 mTestTv.setTextColor(getResource.getColor(R.color.colorAccent));
	}

```

关于第三种方法可以通过注解来通过lint检查,虽然不推荐这种做法,不过如果用得上,知道如何做.

```java
    @TargetApi(Build.VERSION_CODES.M)
    private void api23Call() {
            mTestTv.setTextColor(getColor(R.color.colorAccent));
    }
```
这种做法实际上需要你认真考虑,确保该方法会在正确的平台上执行,也就是api23及以上.采用该做法,可以通过lint检查.




