---
title: Java的回调机制
date: 2016-12-16T18:38:49.000Z
tags:
  - Android
---

自己在学习Java一段时间后回过头来对回调的一个理解。 <!-- more -->

# 前言

# Java 回调学习文章

这个是目前讲回调讲的最好的一片[文章](http://www.cnblogs.com/heshuchao/p/5376298.html)， 三点建议：

1. 其中使用了内部类，不用也是可以的，反而会清晰一点，
2. 接口的话可以直接放到SuperCalculator里。作为它的一部分
3. 在要使用SuperCalculator的时候是通过new出来的，比较好的方式是在Student和Seller的构造函数里面 传进去，然后各自在里面接受，这样优雅一点。

[这篇文章](http://www.bysocket.com/?p=636)补充说明了一下异步回调。其实也很简单，就是讲普通回调加一个线程。将要委托给别人的事情放在一个 线程里面就可以了，然后继续自己的事情，这个在实际工作也是使用比较多的。

# 不理解的根本原因

- 不知道程序运行的方式

在不涉及的多线程的时候，程序是同步执行的，一直往下走，直到跑完代码。相当于只有一个线程，也就是主线程。 当有多线程的时候，也就是说有多个线程。而每个线程都可以跑代码的。例如:你开一个线程

```java
public static void main(String[] args) {
      System.out.println("我在主线程，看看是不是："+Thread.currentThread().getName());// 1

      new Thread(new Runnable() {
          @Override
          public void run() {
              System.out.println("我在哪个子线程呢？看看："+Thread.currentThread().getName());  //2
          }
      }).start();

      System.out.println("我还是在主线程，看看是不是："+Thread.currentThread().getName());  //3
  }

})
```

这里需要这么理解。从main出发，主线程先执行**1** ,看到new Thread 了，则不管了，直接执行3\. 然后我们将视线转到new Thread 里面去，这里可以这么理解，虚拟机又创建了一个子线程A,A只能执行到new Thread范围内的代码，也就是2.现在在全面看一下，主线程和子线程A两者是互相不打扰的，各自执行自己负责的代码，主线程负责执行1和3 子线程A负责2.现在在回到执行结果上，也就是我们这些人类能够看到的东西。肯定是1先执行,而且3肯定在1后面执行。因为对一个线程来说，它是 顺序执行它所负责的代码的。在分析一下2，他是子线程A负责的代码。它和1和3有什么关系呢。2肯定是在1后面的，因为执行1的时候，负责执行2的A 同学还没有出生了。至于2和3的关系则是不确定的，也就是说有可能是123，也有可能是132\. ![这个是123](https://blog-image-1257302654.cos.ap-guangzhou.myqcloud.com/2018-08-24-043828.jpg)。 ![这个是132](https://blog-image-1257302654.cos.ap-guangzhou.myqcloud.com/2018-08-24-043841.jpg)。 这个取决于什么呢？我们大胆分析一下，因为虚拟机创建一个线程也是需要成本的，具体什么成本了，时间和一些其他资源。知道创建线程是需要时间的就可以了。而执行一个语句也是需要时间的。那么执行2和执行3的时间就是未知的了。如果2先执行完，那么就是123，否则就是132了。

- 把回调和异步没有分开。 这其实是两个概念，所以要想知道两者的关系，需要对两者各自的概念搞清楚。回调是什么，异步是什么。 回调我暂时也没有一个完整的概念来形容它，但是看我前面的两篇文章，相信大家有一个清晰的认识。算是一种 模式。A将某件事委托给另外一个人B去做，B做完之后再来告诉A，这个过程就叫回调，而B通过某个函数来告诉A，这个 函数就是回调函数 。而异步是什么，具体到代码层次就是多线程，在主线程开一个线程去做某件事情，而不是在主线程做这件事，那么通过新开一个线程来做一件事的，这种方式就是异步的。他不会阻碍主线程继续执行。那么异步回调是什么概念了。说清楚这个需要先说清楚什么是同步回调。同步回调就是所有代码都是在同一个线程中去执行的，当A委托B去做某件事情的时候，A在没有得到B的回复的时候是不能做其他事情的，需要等待直到需要委托B做的事情做完，再次通过回调回到A中的时候才能继续执行。那再来解释什么是异步回调。异步回调就是A委托B要做的事情，从Ae发起的时候是新开一个线程的，也就是说B在接到委托到执行到回调回去整个过程都是在另外一个线程中完成的。而A在委托之后是可以继续干其他事情的，不用关心和等待B，而B在干完活之后自己通过回调回到A中。

- 不理解接口 害怕接口。害怕的根源是什么，是不了解，是未知。你不了解所以你害怕，躲避它。那么解决办法也很简单，主动去了解他就可以了。 其实接口很简单。 通过第一篇文章，相信大家有有些体会了。某个对象实现一个接口，这翻译过来是什么呢？就是这儿类 具有接口中定义的能力了。老奶奶不是学生，所以肯定是不能通过继承来解决的。但是通过接口就可以很好的解决这个问题，大家都实现doJob()接口。那么大家都有让小红正确干活的能力了。xiaohong知道大家都实现了它需要其他人实现的接口，就可以统一处理。

# 总结

学东西是水到渠成到，刚学一个东西的时候，对某些概念始终不了解。其实不一定是你太笨，只是学习需要一个 过程，等你到了那一步，自然就会明白。比如这个回调，虽然只是一个简单的概念，但是你没有一些知识的储备，你是 很难彻底理解的。所以这个时候不要急，先死记硬背，知道怎么用就可以了。然后继续学习基础知识，当积累到一定程度 再去理解就很容易了。
